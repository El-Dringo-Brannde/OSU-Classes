# Software gains
  - Have had leaps and bounds from removing severe hardware constraints, awkward programming languages, and lack of machine time
  
# Tips
  1. Avoid constructing what can be bought
  2. use rapid prototyping as part of planned iteration to establish spec
  3. Add functions to systems as they are run, used, and tested
  4. identify and develop great conceptual design

# Complexity
  - Software is complex for it's size because they are never the same, or else we'd just combine them into one thing
  - Complexity comes with
    - product flaws
    - cost overruns
    - schedule delays
    - Security holes
    - Difficult to control loose ends

# Conformity
  - It cannot be simplified or this would be a redesign of the software

# Changeability
  - Manufactured things are rarely changed after manufacture
    - Just fixed in the next model
  - great software gets changed because people try to do new things with it and demand extra functionality
  - Must be malleable enough to outlive the machine it runs on
  - #### All of these things force change on the software

# Invisibility
  - Software is not a 2d thing to visualize the same way that normal architecture is
  - It must be wrestled back into hierarchical form in design

# Breakthrough solved accidental Difficulties

## High level languages
  - Free program from accidental complexity
  - Hides the abstract of bits, registers, disks, etc
  
## Unified programming environments
  - Solved Difficulties of using programs together

# Hopes for the silver bullet

#### Ada, programming language
  - The philosophy encompasses modularity

#### OOP
  - Help remove the expression of the design
  - Get rid of type specification

#### AI
  - Using Artificial intelligence must first require the thought on how to solve the problem by a human anyways

#### Expert Systems
  - Rule based programming, computers learn on how people solve problems and emulate them
    - That way they can advise testing strategies, remembering bug type frequencies etc
    - Debugging assistants that are interconnected to being able to find bugs
  - Help maintainance and modification testing
  - This could help novice programmers and almost be like there is an expert programmer right next to them

#### Automatic programming
  - Programs programming just by the given spec
  - But the difficulty comes in finding the correct solution and algorithm in a given program

#### Graphical Programming
  - Seeing a program in the sense of a beefed up flowchart
    - proven to be difficult given the natural complexity of a program or systems

#### Program verification
  - Finding bugs at the system design stage

#### IDE
  - Integration to keep track of a bundle of details working in a group setting

# Promising attacks on the conceptual essence

### Buy vs. Build
  - Buy is better
  - All cost of software goes into development not replication
  - Applicability is growing while the cost goes down

### Requirements refinement and rapid prototyping
  - The hardest part is deciding what to build
    - Cripples the system if done wrong, and the hardest to fix
  - System prototyping that just gets the very basic done and demos

### Incremental development
- Similar to prototyping in that you just get a base model up and running first and add as you go
- Similar to a top down design based on reverse engineering

### Great designers
- The best designers produce faster, smaller, simpler, cleaner.

## The only real silver bullet is finding both a great manager and designer to lead a project 
