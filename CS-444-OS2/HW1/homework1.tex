\documentclass{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx} 
\usepackage{geometry}


\author{Brandon Dring, William Buffum, Samuel Jacobs}
\date{\today}
\title{HW1/Concurrency 1 Write Up \\ CS 444 Spring 2017 }


\begin{document}
\maketitle
\begin{abstract}
    A simple C based solution to the producer and consumer problem. This program requires that you pass in a command line argument number. Whatever number that is passed in at the
    command line, is the number of respective consumer and producer threads. So I.E (hw1 5) will produce 5 producer threads and 5 consumer threads. Each producer that is generated will sleep for a random number generated by rdrand, or the mersenne twister depending on the user computer. Then it will create some more random numbers to be added to the struct, with an arbitrary value, and the sleep number that the element in the struct array posesses. So when a consumer, consumes that element in the struct array, they sleep for the number found in the struct element. And they also print out the other arbitrary random number generated. Also, with a buffer size of 32, if there are 32 elements to the buffer, the producer will wait until the consumer takes a number out. And conversely, if there are 0 elements in the buffer, a consumer will wait til the producers produce something to take out. \newpage
\end{abstract} 
\section{COMMANDS}
A log of commands used to perform the requested actions, as well as a write-up of your concurrency solution.:\\
    \begin{itemize}
        \item mkdir /scratch/spring2017/11-08; cd /scratch/spring2017/11-08\\
        \item git clone git://git.yoctoproject.org/linux-yocto-3.14\\
        \item cp /scratch/opt/environment-setup-i586-poky-linux .\\
        \item cd linux-yocto-3.14; source ../environment-setup-i586-poky-linux\\
        \item cp /scratch/spring2017/files/config-3.14.26-yocto-qemu ./.config\\
        \item make -j4\\
        \item qemu-system-i386 -gdb tcp::5608 -S -nographic -kernel arch/i386/boot/bzImage -drive file=core-image-lsb-sdk-qemux86.ext3,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/vda rw console=ttyS0 debug".\\
        \item (NEWSHELL) \$GDB
        \item target remote :5608  \\
\end{itemize} \newpage

\section{FLAGS}
    An explanation of each and every flag in the listed qemu command-line \\ 
    \begin{itemize}
      \item \textit{-gdb tcp:5608} \\ The “-gdb” option with “tcp:5608” allows us to target the process in gdb and manually continue execution. 
      \item \textit{-S} \\ The “-S” flag stops the cpu from from starting when we boot up the VM. This ensures that we have to manually continue the process from gdb.
      \item \textit{-nographic} \\ “-nographic” allows user to disable graphical output of qemu so that we only work from the commandline.
      \item \textit{-kernel} \\ This flag specifies where the bzImage to boot resides. The bzImage is a compressed kernel image.
      \item \textit{-drive} \\This flag defines a new drive to use. We are using “file=core-image-lsb-sdk-qemux86.ext3” to specify the disk image for this drive. We also use the “if=virtio” to define the type of interface to which the drive connects.
      \item \textit{-enable-kvm} \\ This flag signifies that we have KVM full virtualization support. It allows us to have private virtualized hardware.
      \item \textit{-net} \\ This flag makes sure the no network devices are configured by overriding the default configuration.
      \item \textit{-usb} \\ This flag enables the USB drivers.
      \item \textit{-localtime} \\ This flag is necessary to get the correct data and time.
      \item \textit{ --no-reboot} \\ Instead of rebooting the VM when you run the “reboot” command, it shuts down the VM.
      \item \textit{--append} \\ Uses “root=/dev/vda rw console=ttyS) debug” as the command line for the kernel.
    \end{itemize} \newpage
    
\section{Concurrency Questions}

    \textbf{\textit{What do you think the main point of this assignment is?}} 

         The point of the assignment I think is just a warm up on how to think and implement something concurrently in C. Specifically using the pthreads library, on a *nix based system. Then thinking about how a program can run in parallel, with one thread producing a job to do, and another thread consuming the job that was posted. Along with synchronizing program resources between two threads, so that only one thread can access the shared resource at a time.  There is also a touch at writing some assembly code to use the rdrand command, and storing values in registers. The assignment is really a warm up into getting into a parallel thinking mindset. Apart from just the concurrency exercise, it’s also gives experience into writing a Latex document when most people just use word.\linebreak \linebreak





    \textbf{\textit{How did you personally approach the problem? Design decisions, algorithm, etc.}}  \linebreak

        I personally started with just trying to create the producer, and the resource they share (the struct in this case). Then create the producer function, so that when I spawn off a thread, it can be pointed to a function that uses a mutex and adds to the shared struct value. From there my side was done, my teammate then took over and created the consumer function. So that when a consumer thread is created they can be pointed to a function that sets mutexes consumes the resource. Then my last teammate took over in doing the rdrand implementation and writing the assembly code, and taking in command line arguments that spawns off a passed in value of threads. \linebreak \linebreak


    \textbf{\textit{How did you ensure your solution was correct? Testing details, for instance.}} \linebreak

        To test there was multiple test cases that had to be covered. To start, there had to be the base case of just 2 threads running, one a producer and one a consumer. Both accessing the same shared resource, and synchronizing them with mutexes. Breaking it down further, there was testing solely to make sure that the consumer thread generates the random number efficiently, and places them into the struct, all the way up to the limit, in this case it was 32 entries. Then vice versa, there was testing to make sure that the consumer thread can pull things out of the shared resource.  After that there was testing to make sure that a producer thread doesn’t add to the buffer if it has 32 entries, and that the consumer thread doesn’t pull from a buffer with 0 entities. After that was taking in command line arguments for an arbitrary number of threads to use. We had to make sure that creating more than one producer and one consumer wouldn’t throw the system into deadlock as well. All testing was done via printf, every time a producer/consumer touches the shared struct it logs what it’s values are and what the thread id is that is touching the resource at the time. \linebreak \linebreak


    \textbf{\textit{What did you learn?}}
        
            We as a group learned how to write assembly code in a C file. Along with making a Latex file, and how to compile a Latex file with a Makefile. We also brushed up on our skills of synchronizing multiple threads we create.
    \newpage
    
    \section{Version Control History} 
    \begin{tabular}{l l l}\textbf{Detail} & \textbf{Author} & \textbf{Description}\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/1040abe06276b44779d7090f4dcf3f12aa14f5ff}{1040abe} & El-Dringo-Brannde & Initial commit\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/4bbf81171861f808e93ce47478cca496c0b0fe89}{4bbf811} & El-Dringo-Brannde & Started on Producer\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/840842e72c16c3dd8c5a4971e0ce27ce91b65e69}{840842e} & El-Dringo-Brannde & Test\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/dfd33841d968202f1a7e17cad93e5171b0686031}{dfd3384} & El-Dringo-Brannde & Producer is now.. Producing\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/0c3e4d1e938f4b736ec4c0db4342038bd5dbc06a}{0c3e4d1} & El-Dringo-Brannde & fixed a bug\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/63a39d9f2c3d49abb6fcdd5bfc623eb6ac356553}{63a39d9} & El-Dringo-Brannde & Cleaned up code\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/6e508cad4770626bda31e3f012b218896bf1cf7c}{6e508ca} & El-Dringo-Brannde & Init\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/6d030800ec382b329314ca25581e016269790a0c}{6d03080} & samtjacobs & Added rdrand, consumre\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/2ed62596d4850551f192b7e5b8175e69526b1bd8}{2ed6259} & samtjacobs & Style changes\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/6cb351f9c34417f60e7f8d71a179d2eb09c335b4}{6cb351f} & El-Dringo-Brannde & Turn in ready\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/14b1d306e9d1f67d1826a2e3264f9e88ecc7aca2}{14b1d30} & El-Dringo-Brannde & Merge branch 'master' of https://github.com/El-Dringo-Brannde/CS444\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/b156e61fdf6792555162b1e4dcd74d6cd2be8e0f}{b156e61} & El-Dringo-Brannde & Real turn in ready\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/ea2bf27826aeaca0e6569fe4f30d000e668cf2f9}{ea2bf27} & WilliamBuffum & added commandline arguments for user to specify number of each thread\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/b34f487448d60dbf56a5fd32ce0b26f427761d85}{b34f487} & El-Dringo-Brannde & Fixed negative index issue added some debug stuff\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/b6f0da086658854d9b7f1fff40dddab9daa5fd8d}{b6f0da0} & samtjacobs & Added makefile\\\hline
\href{https://github.com/El-Dringo-Brannde/CS444/commit/e8b356d587abec4a48ff17831b3add9dd65beed8}{e8b356d} & El-Dringo-Brannde & Fixed multithreading issue and code style changes\\\hline
\end{tabular} 
\newpage

\subsection*{Work Log }
\begin{itemize}
  \item \textit{4-13-2017}\\ Brandon Dring started on instantiating producer \\
  \item \textit{4-13-2017} \\ Brandon Dring Producer thread now adds to the buffer struct and increments index \\ 
  \item \textit{4-13-2017}\\ Brandon Dring refactored the code to be more readable \\
  \item \textit{4-13-2017}\\ Brandon Dring Changed from sleeping if the buffer is full to setting a mutex condition variable \\
  \item \textit{4-19-2017}\\  Samuel Jacobs Implemented rdrand and the consumer threads to work appropriately\\
  \item \textit{4-19-2017}\\ Samuel Jacobs Refactored code to be more readable and changed the names of some variables, along with altering control flow \\
  \item \textit{4-20-2017}\\ William Buffum Implemented command line arguments to be able to dictate number of threads spawned \\ 
  \item \textit{4-21-2017}\\ Brandon Dring Fixed bug where consumers would pull items at a negative index. 
  \item \textit{4-21-2017} \\ Brandon Dring Fixed multithreading bug where both consumer and producer would add and pull when they aren't supposed too.
  \item \textit{4-21-2017} \\ Brandon Dring Added a script that produces a git log of the VCS repo
\end{itemize}

\end{document}

